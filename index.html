<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Expense Tracker</title>
    <!-- Add Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        body {
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            padding-bottom: 40px;
        }

        .card {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 24px;
            margin-bottom: 20px;
            transition: transform 0.2s;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        h1 {
            color: #2e7d32;
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 24px;
            text-align: center;
        }

        .current-month {
            font-weight: 500;
            color: #2e7d32;
            margin-bottom: 16px;
            font-size: 18px;
            text-align: center;
        }

        #currentDateTime {
            color: #666;
            text-align: center;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .wallet-info {
            background: #e8f5e9;
            color: #2d3436;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .wallet-info h3 {
            font-size: 20px;
            margin-bottom: 12px;
            font-weight: 500;
            color: #2e7d32;
        }

        .wallet-info p {
            font-size: 16px;
            margin: 8px 0;
        }

        /* Style for positive/negative values */
        .positive {
            color: #2e7d32;
            font-weight: 500;
        }

        table .positive {
            color: #2e7d32;
            font-weight: 500;
        }

        .negative {
            color: #d32f2f;
            font-weight: 500;
        }

        table .negative {
            color: #d32f2f;
            font-weight: 500;
        }

        .input-section {
            display: flex;
            gap: 12px;
            margin-bottom: 24px;
        }

        input[type="number"] {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus {
            border-color: #1a73e8;
            outline: none;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background-color: #2e7d32;
            color: white;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        button:hover {
            background-color: #1b5e20;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .archive-section {
            margin: 24px 0;
        }

        .archive-dropdown {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 16px;
            background-color: white;
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 24px;
            overflow: hidden;
            border-radius: 12px;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        th, td {
            padding: 16px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        th {
            background-color: #f8f9fa;
            font-weight: 500;
            color: #2e7d32;
        }

        tr:last-child td {
            border-bottom: none;
        }

        /* Keep delete button red */
        .delete-button {
            background-color: #d32f2f;
            padding: 8px 16px;
            font-size: 14px;
        }

        .delete-button:hover {
            background-color: #b71c1c;
        }

        /* Backup section styling */
        .backup-section {
            margin-top: 24px;
            padding-bottom: 20px;
        }

        .backup-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        /* Backup buttons in green theme */
        .backup-button {
            background-color: #2e7d32;
            flex: 1;
            justify-content: center;
        }

        .backup-button:hover {
            background-color: #1b5e20;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }

            h1 {
                font-size: 24px;
            }

            .input-section {
                flex-direction: column;
            }

            input[type="number"] {
                width: 100%;
            }

            button {
                width: 100%;
                justify-content: center;
            }

            /* Mobile table styles */
            table {
                margin-top: 0;
            }

            th, td {
                padding: 8px 4px;
                font-size: 13px;
            }

            /* Adjust date column */
            th:first-child, td:first-child {
                max-width: 90px;
                font-size: 12px;
            }

            /* Make amount and balance columns more compact */
            th:nth-child(2), td:nth-child(2),
            th:nth-child(3), td:nth-child(3) {
                padding-left: 2px;
                padding-right: 2px;
            }

            /* Compact delete button */
            .delete-button {
                padding: 4px 8px;
                font-size: 12px;
            }

            .delete-button .material-icons {
                font-size: 16px;
            }

            /* Adjust column widths */
            th:nth-child(2), td:nth-child(2),
            th:nth-child(3), td:nth-child(3) {
                width: 20%;
            }

            th:last-child, td:last-child {
                width: 15%;
            }
        }

        /* Add animation for new entries */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .new-entry {
            animation: fadeIn 0.3s ease-out;
        }

        /* Loading spinner */
        .loading {
            opacity: 0.7;
            position: relative;
        }

        .loading::after {
            content: "";
            position: absolute;
            width: 20px;
            height: 20px;
            top: 50%;
            left: 50%;
            margin: -10px 0 0 -10px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #1a73e8;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            <span class="material-icons" style="vertical-align: middle; margin-right: 8px;">account_balance_wallet</span>
            Daily Expense Tracker
        </h1>
        
        <div class="current-month" id="currentMonth"></div>
        
        <div id="currentDateTime"></div>
        
        <div class="wallet-info card">
            <h3>
                <span class="material-icons" style="vertical-align: middle; margin-right: 8px;">savings</span>
                Wallet Status
            </h3>
            <p>Current Balance: <span id="walletBalance">Loading...</span></p>
            <p>Daily Addition: <strong>50</strong></p>
        </div>

        <div class="input-section">
            <input type="number" id="expenseAmount" placeholder="Enter amount spent">
            <button onclick="addExpense()" id="addButton">
                <span class="material-icons">add_circle</span>
                Add Expense
            </button>
        </div>

        <div class="archive-section card">
            <h3>
                <span class="material-icons" style="vertical-align: middle; margin-right: 8px;">history</span>
                View Archived Months
            </h3>
            <select id="archiveSelect" class="archive-dropdown" onchange="loadArchivedMonth()">
                <option value="">Current Month</option>
            </select>
        </div>

        <div class="card">
            <table>
                <thead>
                    <tr>
                        <th>Date & Time</th>
                        <th>Amount</th>
                        <th>Balance</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody id="expenseTable">
                </tbody>
            </table>
        </div>

        <div class="backup-section card">
            <h3>
                <span class="material-icons" style="vertical-align: middle; margin-right: 8px;">backup</span>
                Backup Data
            </h3>
            <div class="backup-buttons">
                <button onclick="exportData()" class="backup-button">
                    <span class="material-icons">cloud_download</span>
                    Export Data
                </button>
                <button onclick="document.getElementById('importFile').click()" class="backup-button">
                    <span class="material-icons">cloud_upload</span>
                    Import Data
                </button>
                <input type="file" id="importFile" style="display: none" onchange="importData(event)" accept=".json">
            </div>
        </div>
    </div>

    <script>
        // Initialize IndexedDB
        let db;
        const DB_NAME = 'ExpenseTrackerDB';
        const DB_VERSION = 1;
        let expenses = [];
        let walletBalance = 0;
        const DAILY_ADDITION = 50;
        let currentServerTime;

        const dbPromise = new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onerror = event => {
                console.error('Database error:', event.target.error);
                reject(event.target.error);
            };

            request.onsuccess = event => {
                db = event.target.result;
                resolve(db);
            };

            request.onupgradeneeded = event => {
                const db = event.target.result;
                
                // Create expenses store
                if (!db.objectStoreNames.contains('expenses')) {
                    const expenseStore = db.createObjectStore('expenses', { keyPath: 'id', autoIncrement: true });
                    expenseStore.createIndex('date', 'date');
                }
                
                // Create wallet store
                if (!db.objectStoreNames.contains('wallet')) {
                    db.createObjectStore('wallet', { keyPath: 'id' });
                }

                // Create archives store
                if (!db.objectStoreNames.contains('archives')) {
                    const archiveStore = db.createObjectStore('archives', { keyPath: 'monthKey' });
                    archiveStore.createIndex('date', 'date');
                }
            };
        });

        // Load data from IndexedDB
        async function loadData() {
            try {
                await dbPromise;
                
                // Load expenses
                const expenseStore = db.transaction('expenses', 'readonly').objectStore('expenses');
                expenses = await new Promise((resolve, reject) => {
                    const request = expenseStore.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });

                // Load wallet balance
                const walletStore = db.transaction('wallet', 'readonly').objectStore('wallet');
                const walletData = await new Promise((resolve, reject) => {
                    const request = walletStore.get(1);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });

                if (walletData) {
                    walletBalance = walletData.balance;
                } else {
                    await calculateInitialBalance();
                }

                updateTable();
                updateWalletDisplay();
                updateCurrentMonth();
            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        async function getCurrentTime() {
            try {
                const response = await fetch('https://timeapi.io/api/Time/current/zone?timeZone=Asia/Riyadh', {
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                currentServerTime = new Date(data.dateTime);
                updateTimeDisplay(currentServerTime);
                return currentServerTime;
            } catch (error) {
                console.error('Error fetching time:', error);
                const localTime = new Date();
                updateTimeDisplay(localTime, true);
                return localTime;
            }
        }

        function updateTimeDisplay(time, isLocal = false) {
            const dateTimeElement = document.getElementById('currentDateTime');
            const timeString = time.toLocaleString('en-US', { timeZone: 'Asia/Riyadh' });
            dateTimeElement.textContent = `Current Date & Time (Saudi Arabia): ${timeString}`;
            if (isLocal) {
                dateTimeElement.textContent += ' (Using local time - offline mode)';
            }
        }

        async function calculateInitialBalance() {
            const currentDate = await getCurrentTime();
            const dayOfMonth = currentDate.getDate();
            
            if (dayOfMonth >= 3) {
                const daysToCount = dayOfMonth - 2; // Count days since day 3
                walletBalance = DAILY_ADDITION * daysToCount;
            } else {
                walletBalance = 0;
            }

            // Save to IndexedDB
            const walletStore = db.transaction('wallet', 'readwrite').objectStore('wallet');
            await new Promise((resolve, reject) => {
                const request = walletStore.put({
                    id: 1,
                    balance: walletBalance,
                    lastUpdated: new Date().toISOString()
                });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });

            updateWalletDisplay();
            return walletBalance;
        }

        async function addExpense() {
            const amount = parseFloat(document.getElementById('expenseAmount').value);
            if (isNaN(amount) || amount <= 0) {
                alert('Please enter a valid amount');
                return;
            }

            const addButton = document.getElementById('addButton');
            addButton.classList.add('loading');

            try {
                const now = await getCurrentTime();
                
                const expense = {
                    date: now.toISOString(),
                    amount: amount,
                    walletBalance: walletBalance - amount
                };

                // Save expense to IndexedDB
                const expenseStore = db.transaction('expenses', 'readwrite').objectStore('expenses');
                await new Promise((resolve, reject) => {
                    const request = expenseStore.add(expense);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });

                // Update wallet balance
                walletBalance -= amount;
                const walletStore = db.transaction('wallet', 'readwrite').objectStore('wallet');
                await new Promise((resolve, reject) => {
                    const request = walletStore.put({
                        id: 1,
                        balance: walletBalance,
                        lastUpdated: new Date().toISOString()
                    });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });

                expenses.unshift(expense);
                updateTable();
                updateWalletDisplay();
                document.getElementById('expenseAmount').value = '';
            } catch (error) {
                console.error('Error saving expense:', error);
                alert('Error saving expense. Please try again.');
            } finally {
                addButton.classList.remove('loading');
            }
        }

        async function deleteExpense(expenseId, amount) {
            try {
                // Delete from IndexedDB
                const expenseStore = db.transaction('expenses', 'readwrite').objectStore('expenses');
                await new Promise((resolve, reject) => {
                    const request = expenseStore.delete(expenseId);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });

                // Remove from expenses array
                expenses = expenses.filter(exp => exp.id !== expenseId);

                // Recalculate wallet balance
                const currentDate = await getCurrentTime();
                const dayOfMonth = currentDate.getDate();
                
                if (dayOfMonth >= 3) {
                    const daysToCount = dayOfMonth - 2;
                    walletBalance = DAILY_ADDITION * daysToCount;
                } else {
                    walletBalance = 0;
                }

                // Subtract all expenses except the deleted one
                for (let expense of expenses) {
                    walletBalance -= expense.amount;
                }

                // Update wallet in IndexedDB
                const walletStore = db.transaction('wallet', 'readwrite').objectStore('wallet');
                await new Promise((resolve, reject) => {
                    const request = walletStore.put({
                        id: 1,
                        balance: walletBalance,
                        lastUpdated: new Date().toISOString()
                    });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });

                updateTable();
                updateWalletDisplay();
            } catch (error) {
                console.error('Error deleting expense:', error);
                alert('Error deleting expense. Please try again.');
            }
        }

        function updateTable() {
            const tableBody = document.getElementById('expenseTable');
            tableBody.innerHTML = '';
            
            expenses.forEach((expense, index) => {
                const row = document.createElement('tr');
                if (index === 0) row.classList.add('new-entry');
                const date = new Date(expense.date);
                row.innerHTML = `
                    <td>${date.toLocaleString('en-US', { timeZone: 'Asia/Riyadh' })}</td>
                    <td>${expense.amount.toFixed(2)}</td>
                    <td class="${expense.walletBalance >= 0 ? 'positive' : 'negative'}">
                        ${expense.walletBalance.toFixed(2)}
                    </td>
                    <td>
                        <button onclick="deleteExpense(${expense.id}, ${expense.amount})" 
                                class="delete-button">
                            <span class="material-icons">delete</span>
                        </button>
                    </td>
                `;
                tableBody.appendChild(row);
            });
        }

        // Modify updateWalletDisplay to add color classes
        function updateWalletDisplay() {
            const walletBalanceElement = document.getElementById('walletBalance');
            walletBalanceElement.textContent = walletBalance.toFixed(2);
            
            // Remove existing classes
            walletBalanceElement.classList.remove('positive', 'negative');
            // Add appropriate class based on balance
            if (walletBalance >= 0) {
                walletBalanceElement.classList.add('positive');
            } else {
                walletBalanceElement.classList.add('negative');
            }
        }

        // Export data to JSON file
        function exportData() {
            const data = {
                expenses: expenses,
                walletBalance: walletBalance,
                lastUpdate: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'expense-tracker-backup.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Import data from JSON file
        async function importData(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;

                const text = await file.text();
                const data = JSON.parse(text);

                // Validate data structure
                if (!Array.isArray(data.expenses) || typeof data.walletBalance !== 'number') {
                    throw new Error('Invalid backup file format');
                }

                // Clear existing data
                const expenseStore = db.transaction('expenses', 'readwrite').objectStore('expenses');
                await new Promise((resolve, reject) => {
                    const request = expenseStore.clear();
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });

                // Import new expenses
                for (const expense of data.expenses) {
                    await new Promise((resolve, reject) => {
                        const request = expenseStore.add(expense);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                }

                // Update wallet balance
                const walletStore = db.transaction('wallet', 'readwrite').objectStore('wallet');
                await new Promise((resolve, reject) => {
                    const request = walletStore.put({
                        id: 1,
                        balance: data.walletBalance,
                        lastUpdated: new Date().toISOString()
                    });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });

                expenses = data.expenses;
                walletBalance = data.walletBalance;
                updateTable();
                updateWalletDisplay();
                alert('Data imported successfully!');
            } catch (error) {
                console.error('Error importing data:', error);
                alert('Error importing data. Please check the file format.');
            }
            event.target.value = ''; // Reset file input
        }

        async function checkAndArchive() {
            const currentDate = await getCurrentTime();
            const dayOfMonth = currentDate.getDate();
            
            if (dayOfMonth === 3) {
                // Get previous month's data
                const prevMonth = new Date(currentDate);
                prevMonth.setMonth(prevMonth.getMonth() - 1);
                const monthKey = `${(prevMonth.getMonth() + 1).toString().padStart(2, '0')}-${prevMonth.getFullYear()}`;
                
                // Filter expenses for previous month
                const prevMonthExpenses = expenses.filter(exp => {
                    const expDate = new Date(exp.date);
                    return expDate.getMonth() === prevMonth.getMonth() && 
                           expDate.getFullYear() === prevMonth.getFullYear();
                });

                if (prevMonthExpenses.length > 0) {
                    // Save to archives
                    const archiveStore = db.transaction('archives', 'readwrite').objectStore('archives');
                    await new Promise((resolve, reject) => {
                        const request = archiveStore.put({
                            monthKey: monthKey,
                            expenses: prevMonthExpenses,
                            finalBalance: walletBalance,
                            date: prevMonth.toISOString()
                        });
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });

                    // Clear previous month's expenses
                    const expenseStore = db.transaction('expenses', 'readwrite').objectStore('expenses');
                    for (const exp of prevMonthExpenses) {
                        await new Promise((resolve, reject) => {
                            const request = expenseStore.delete(exp.id);
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(request.error);
                        });
                    }

                    // Update expenses array
                    expenses = expenses.filter(exp => !prevMonthExpenses.includes(exp));
                    
                    // Reset wallet balance for new month
                    await calculateInitialBalance();
                    
                    // Update display
                    updateTable();
                    updateWalletDisplay();
                    await updateArchiveList();
                }
            }
        }

        async function updateArchiveList() {
            const archiveStore = db.transaction('archives', 'readonly').objectStore('archives');
            const archives = await new Promise((resolve, reject) => {
                const request = archiveStore.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });

            const select = document.getElementById('archiveSelect');
            // Keep only the first option (Current Month)
            select.innerHTML = '<option value="">Current Month</option>';
            
            // Add archived months
            archives.sort((a, b) => new Date(b.date) - new Date(a.date))
                   .forEach(archive => {
                       const option = document.createElement('option');
                       option.value = archive.monthKey;
                       option.textContent = archive.monthKey;
                       select.appendChild(option);
                   });
        }

        async function loadArchivedMonth() {
            const select = document.getElementById('archiveSelect');
            const monthKey = select.value;

            if (!monthKey) {
                updateTable();
                return;
            }

            const archiveStore = db.transaction('archives', 'readonly').objectStore('archives');
            const archive = await new Promise((resolve, reject) => {
                const request = archiveStore.get(monthKey);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });

            if (archive) {
                const tableBody = document.getElementById('expenseTable');
                tableBody.innerHTML = '';
                
                archive.expenses.forEach(expense => {
                    const row = document.createElement('tr');
                    const date = new Date(expense.date);
                    row.innerHTML = `
                        <td>${date.toLocaleString('en-US', { timeZone: 'Asia/Riyadh' })}</td>
                        <td>${expense.amount.toFixed(2)}</td>
                        <td class="${expense.walletBalance >= 0 ? 'positive' : 'negative'}">
                            ${expense.walletBalance.toFixed(2)}
                        </td>
                        <td>
                            <button disabled class="delete-button" style="background-color: #9e9e9e;">
                                <span class="material-icons">archive</span>
                            </button>
                        </td>
                    `;
                    tableBody.appendChild(row);
                });
            }
        }

        function updateCurrentMonth() {
            const now = new Date();
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
            document.getElementById('currentMonth').textContent = 
                `Current Month: ${monthNames[now.getMonth()]} ${now.getFullYear()}`;
        }

        // Initialize when page loads
        async function initialize() {
            await loadData();
            await checkAndArchive();
            await updateArchiveList();
            updateCurrentMonth();
            setInterval(getCurrentTime, 60000);
            setInterval(checkAndArchive, 3600000); // Check every hour
        }

        // Start the application
        initialize();
    </script>
</body>
</html> 
